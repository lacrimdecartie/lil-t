// @ts-nocheck
"use client";

import React, { useCallback, useEffect } from "react";
import ReactFlow, {
  Background, Controls, MiniMap,
  addEdge, MarkerType,
  useNodesState, useEdgesState, useReactFlow, ReactFlowProvider,
  ConnectionMode
} from "reactflow";
import "reactflow/dist/style.css";

import EditableNode from "@/components/nodes/EditableNode";

// --- Auto-Handle-Picker: wählt für zwei Knoten die kürzeste Seiten-Kombi ---
function pickAutoHandles(rf: any, sourceId?: string|null, targetId?: string|null) {
  if (!sourceId || !targetId) return {};
  const s = rf.getNode(String(sourceId));
  const t = rf.getNode(String(targetId));
  if (!s || !t || !s.positionAbsolute || !t.positionAbsolute) return {};

  const sW = (s.width ?? s.measured?.width ?? 0);
  const sH = (s.height ?? s.measured?.height ?? 0);
  const tW = (t.width ?? t.measured?.width ?? 0);
  const tH = (t.height ?? t.measured?.height ?? 0);

  const sX = s.positionAbsolute.x, sY = s.positionAbsolute.y;
  const tX = t.positionAbsolute.x, tY = t.positionAbsolute.y;

  const sPts: Record<string,[number,number]> = {
    L:[sX, sY+sH/2], R:[sX+sW, sY+sH/2], T:[sX+sW/2, sY], B:[sX+sW/2, sY+sH]
  };
  const tPts: Record<string,[number,number]> = {
    L:[tX, tY+tH/2], R:[tX+tW, tY+tH/2], T:[tX+tW/2, tY], B:[tX+tW/2, tY+tH]
  };

  let best: {sKey:keyof typeof sPts; tKey:keyof typeof tPts; d2:number} | null = null;
  (Object.keys(sPts) as Array<keyof typeof sPts>).forEach(sKey => {
    (Object.keys(tPts) as Array<keyof typeof tPts>).forEach(tKey => {
      const [ax, ay] = sPts[sKey], [bx, by] = tPts[tKey];
      const d2 = (ax-bx)*(ax-bx) + (ay-by)*(ay-by);
      if (!best || d2 < best.d2) best = { sKey, tKey, d2 };
    });
  });

  return best ? { sourceHandle: `${best.sKey}-src`, targetHandle: `${best.tKey}-tgt` } : {};
}

const nodeTypes = { editable: EditableNode };

function Inner() {
  const mapId = "default-map";
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const rf = useReactFlow();

  // Initial: Nodes laden, dann Edges mit Auto-Handles setzen
  useEffect(() => {
    let alive = true;
    (async () => {
      const ns = await fetch(`/api/nodes?mapId=${mapId}`).then(r=>r.json());
      const es = await fetch(`/api/edges?mapId=${mapId}`).then(r=>r.json());

      if (!alive) return;
      setNodes(ns.map((n:any) => ({
        id: String(n.id),
        type: "editable",
        position: { x: n.x ?? 0, y: n.y ?? 0 },
        data: { label: n.label, color: n.color ?? "#FBBF24" }
      })));

      // nach Render der Nodes: Edges mit Auto-Handles berechnen
      requestAnimationFrame(() => {
        if (!alive) return;
        setEdges(() => es.map((e:any) => {
          const h = pickAutoHandles(rf, e.sourceId, e.targetId);
          return {
            id: String(e.id),
            source: String(e.sourceId),
            target: String(e.targetId),
            sourceHandle: h.sourceHandle,
            targetHandle: h.targetHandle,
            type: "bezier",
            markerEnd: { type: MarkerType.ArrowClosed },
          };
        }));
      });
    })();
    return () => { alive = false; };
  }, [mapId, rf, setNodes, setEdges]);

  // Verbinden durch Ziehen (Drag & Drop)
  const onConnect = useCallback((params: any) => {
    const { sourceHandle, targetHandle } = pickAutoHandles(rf, params.source, params.target);
    setEdges((eds) =>
      addEdge(
        { ...params, sourceHandle, targetHandle, type: "bezier", markerEnd: { type: MarkerType.ArrowClosed } },
        eds
      )
    );
  }, [rf, setEdges]);

  return (
    <div className="w-full h-[calc(100vh-64px)]">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        connectionMode={ConnectionMode.Loose}
        defaultEdgeOptions={{ type: "bezier", markerEnd: { type: MarkerType.ArrowClosed } }}
        fitView
      >
        <Background />
        <MiniMap pannable zoomable />
        <Controls />
      </ReactFlow>
    </div>
  );
}

export default function Editor() {
  return (
    <ReactFlowProvider>
      <Inner />
    </ReactFlowProvider>
  );
}
