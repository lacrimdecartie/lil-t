// @ts-nocheck
"use client";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import ReactFlow, {
  Background, Controls, MiniMap,
  addEdge, MarkerType,
  useNodesState, useEdgesState, useReactFlow, ReactFlowProvider,
  ConnectionMode, type Node as RFNode, type Edge as RFEdge,
  type NodeMouseHandler, type EdgeMouseHandler, type NodeDragHandler
} from "reactflow";
import "reactflow/dist/style.css";

import EditableNode from "@/components/nodes/EditableNode";
import ParallelBezier from "@/components/edges/ParallelBezier";
import ContextMenu, { type MenuItem } from "@/components/ContextMenu";


// == Auto-handle refresher ==
function __applyAutoHandles(rf:any, list:any[]) {
  return list.map((e:any) => {
    const h = pickAutoHandles(rf, e.source ?? e.sourceId, e.target ?? e.targetId);
    return {
      ...e,
      source: String(e.source ?? e.sourceId),
      target: String(e.target ?? e.targetId),
      sourceHandle: h.sourceHandle,
      targetHandle: h.targetHandle,
    };
  });
}

const nodeTypes = { editable: EditableNode };
const edgeTypes = { parallel: ParallelBezier };

// ---------- Auto-Handle kürzeste Seite ----------
function pickAutoHandles(rf: any, sourceId?: string|null, targetId?: string|null) {
  if (!sourceId || !targetId) return {};
  const s = rf.getNode(String(sourceId));
  const t = rf.getNode(String(targetId));
  if (!s || !t || !s.positionAbsolute || !t.positionAbsolute) return {};

  const sW = (s.width ?? (s as any).measured?.width ?? 0);
  const sH = (s.height ?? (s as any).measured?.height ?? 0);
  const tW = (t.width ?? (t as any).measured?.width ?? 0);
  const tH = (t.height ?? (t as any).measured?.height ?? 0);

  const sX = s.positionAbsolute.x, sY = s.positionAbsolute.y;
  const tX = t.positionAbsolute.x, tY = t.positionAbsolute.y;

  const sPts: Record<string,[number,number]> = {
    L:[sX, sY+sH/2], R:[sX+sW, sY+sH/2], T:[sX+sW/2, sY], B:[sX+sW/2, sY+sH]
  };
  const tPts: Record<string,[number,number]> = {
    L:[tX, tY+tH/2], R:[tX+tW, tY+tH/2], T:[tX+tW/2, tY], B:[tX+tW/2, tY+tH]
  };

  const dx = (tX + tW/2) - (sX + sW/2);
  const dy = (tY + tH/2) - (sY + sH/2);
  const preferH = Math.abs(dx) >= Math.abs(dy);
  const sOrder = preferH ? (dx >= 0 ? ["R","L","T","B"] : ["L","R","T","B"])
                         : (dy >= 0 ? ["B","T","L","R"] : ["T","B","L","R"]);
  const tOrder = preferH ? (dx >= 0 ? ["L","R","T","B"] : ["R","L","T","B"])
                         : (dy >= 0 ? ["T","B","L","R"] : ["B","T","L","R"]);

  let best: any = null;
  for (const sk of sOrder) for (const tk of tOrder) {
    const [ax,ay] = sPts[sk], [bx,by] = tPts[tk];
    const d2 = (ax-bx)*(ax-bx) + (ay-by)*(ay-by);
    const nonPref = preferH ? ((sk==="T"||sk==="B"||tk==="T"||tk==="B"))
                            : ((sk==="L"||sk==="R"||tk==="L"||tk==="R"));
    const score = d2 + (nonPref ? 400 : 0);
    if (!best || score < best.score) best = { sk, tk, score };
  }
  return best ? { sourceHandle: `${best.sk}-src`, targetHandle: `${best.tk}-tgt` } : {};
}

// ---------- Parallele Kanten-Ranking ----------
function rankParallels(list:any[]) {
  const groups = new Map<string, any[]>();
  for (const e of list) {
    const key = `${e.source}->${e.target}`;
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key)!.push(e);
  }
  const out:any[] = [];
  groups.forEach(arr => {
    arr.sort((a,b)=> String(a.id).localeCompare(String(b.id)));
    const n = arr.length, mid = (n-1)/2;
    arr.forEach((e,i)=>{
      const idx = i - mid;
      e.type = "parallel";
      e.data = { ...(e.data||{}), parIndex: idx };
      out.push(e);
    });
  });
  return out;
}

// ---------- Context-Menü State ----------
type Ctx = { open:boolean; x:number; y:number };
type NodeCtx = Ctx & { nodeId?: string };
type EdgeCtx = Ctx & { edgeId?: string };

function Inner() {
  const mapId = "default-map";
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const rf = useReactFlow();

  // Theme: je nach Uhrzeit (7–19 hell, sonst dunkel)
  useEffect(()=>{
    const h = new Date().getHours();
    const theme = (h>=7 && h<19) ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", theme);
  },[]);

  // Kontextmenüs
  const [paneCtx, setPaneCtx] = useState<Ctx>({open:false,x:0,y:0});
  const [nodeCtx, setNodeCtx] = useState<NodeCtx>({open:false,x:0,y:0});
  const [edgeCtx, setEdgeCtx] = useState<EdgeCtx>({open:false,x:0,y:0});

  // Initiale Daten
  useEffect(() => {
    let alive = true;
    (async () => {
      const ns = await fetch(`/api/nodes?mapId=${mapId}`).then(r=>r.json());
      const es = await fetch(`/api/edges?mapId=${mapId}`).then(r=>r.json());
      if (!alive) return;

      setNodes(ns.map((n:any)=>({
        id:String(n.id), type:"editable",
        position:{ x:n.x??0, y:n.y??0 },
        data:{ label:n.label, color:n.color ?? "#60A5FA" }
      })));

      const built = es.map((e:any)=>{
        const h = pickAutoHandles(rf, e.sourceId, e.targetId);
        return {
          id:String(e.id),
          source:String(e.sourceId),
          target:String(e.targetId),
          sourceHandle:h.sourceHandle,
          targetHandle:h.targetHandle,
          type:"parallel",
          data:{ color: e.color ?? undefined, label: e.label ?? undefined },
          markerEnd:{ type: MarkerType.ArrowClosed }
        };
      });
      setEdges(rankParallels(built));
    })();
    return ()=>{ alive=false; };
  }, [mapId, rf, setNodes, setEdges]);

  // Verbinden via Drag
  const onConnect = useCallback((params: any) => {
  const { sourceHandle, targetHandle } = pickAutoHandles(rf, params.source, params.target);
  setEdges((eds: any[]) => __applyAutoHandles(rf,
    addEdge(
      { ...params, sourceHandle, targetHandle, type: "parallel", markerEnd: { type: MarkerType.ArrowClosed } },
      eds
    )
  ));
}, [rf, setEdges]);
// Position speichern (Server)
  const onNodeDragStop: NodeDragHandler = useCallback((_e, node)=>{
    fetch(`/api/nodes/${node.id}`,{
      method:"PATCH", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ x: node.position.x, y: node.position.y })
    }).catch(()=>{});
  },[]);

  // ----- Pane / Node / Edge Kontextmenüs öffnen -----
  const onPaneContextMenu = useCallback((e: React.MouseEvent)=>{
    e.preventDefault(); setPaneCtx({open:true,x:e.clientX,y:e.clientY});
  },[]);
  const onNodeContextMenu: NodeMouseHandler = useCallback((e,node)=>{
    e.preventDefault(); e.stopPropagation();
    setNodeCtx({open:true,x:e.clientX,y:e.clientY,nodeId: node.id});
  },[]);
  const onEdgeContextMenu: EdgeMouseHandler = useCallback((e,edge)=>{
    e.preventDefault(); e.stopPropagation();
    setEdgeCtx({open:true,x:e.clientX,y:e.clientY,edgeId: edge.id});
  },[]);
  const closePaneMenu = useCallback(()=> setPaneCtx(s=>({...s,open:false})),[]);
  const closeNodeMenu = useCallback(()=> setNodeCtx(s=>({...s,open:false})),[]);
  const closeEdgeMenu = useCallback(()=> setEdgeCtx(s=>({...s,open:false})),[]);

  // ----- Aktionen: Node -----
  const addNodeHere = useCallback(async (x:number,y:number)=>{
    const newX = x, newY = y;
    const node = await fetch(`/api/nodes`,{
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ mapId, label:"Neuer Knoten", x:newX, y:newY, color:"#60A5FA" })
    }).then(r=>r.json());
    setNodes(nds => [...nds,{
      id:String(node.id), type:"editable",
      data:{ label:String(node.label), color: node.color ?? "#60A5FA" },
      position:{ x:newX, y:newY }
    }]);
  },[mapId,setNodes]);

  const addNodeFromNode = useCallback(async (fromId:string)=>{
    const from = rf.getNode(fromId);
    const base = from?.positionAbsolute ?? {x:0,y:0};
    const newX = base.x + 240, newY = base.y + 40;
    const node = await fetch(`/api/nodes`,{
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ mapId, label:"Neuer Knoten", x:newX, y:newY, color:"#60A5FA" })
    }).then(r=>r.json());

    setNodes(nds => [...nds,{
      id:String(node.id), type:"editable",
      data:{ label:String(node.label), color: node.color ?? "#60A5FA" },
      position:{ x:newX, y:newY }
    }]);

    const edge = await fetch(`/api/edges`,{
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ mapId, sourceId: fromId, targetId: node.id, directed: true })
    }).then(r=>r.json());

    const auto = pickAutoHandles(rf, String(edge.sourceId), String(edge.targetId));
    setEdges(eds => rankParallels([...eds,{
      id:String(edge.id), source:String(edge.sourceId), target:String(edge.targetId),
      sourceHandle:auto.sourceHandle, targetHandle:auto.targetHandle,
      type:"parallel", data:{}, markerEnd:{ type: MarkerType.ArrowClosed }
    }]));
  },[mapId, rf, setNodes, setEdges]);

  const deleteNode = useCallback(async (nodeId:string)=>{
    await fetch(`/api/nodes/${nodeId}`,{ method:"DELETE" }).catch(()=>{});
    setNodes(nds => nds.filter((n:any)=>n.id!==nodeId));
    setEdges(eds => eds.filter((e:any)=> e.source!==nodeId && e.target!==nodeId ));
  },[setNodes,setEdges]);

  const renameNode = useCallback(async (nodeId:string)=>{
    const current = nodes.find((n:any)=>n.id===nodeId)?.data?.label ?? "";
    const next = window.prompt("Neuer Name:", current);
    if (next==null) return;
    setNodes(nds => nds.map((n:any)=> n.id===nodeId ? { ...n, data:{...n.data, label: next} } : n));
    await fetch(`/api/nodes/${nodeId}`,{
      method:"PATCH", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ label: next })
    }).catch(()=>{});
  },[nodes,setNodes]);

  const colorNode = useCallback(async (nodeId:string, hex:string)=>{
    setNodes(nds => nds.map((n:any)=> n.id===nodeId ? { ...n, data:{...n.data, color: hex} } : n));
    await fetch(`/api/nodes/${nodeId}`,{
      method:"PATCH", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ color: hex })
    }).catch(()=>{});
  },[setNodes]);

  // ----- Aktionen: Edge -----
  const deleteEdge = useCallback(async (edgeId:string)=>{
    await fetch(`/api/edges/${edgeId}`,{ method:"DELETE" }).catch(()=>{});
    setEdges(eds => eds.filter((e:any)=> e.id!==edgeId));
  },[setEdges]);

  const labelEdge = useCallback(async (edgeId:string)=>{
    const current = edges.find((e:any)=>e.id===edgeId)?.data?.label ?? "";
    const next = window.prompt("Relation-Text:", current);
    if (next==null) return;
    setEdges(eds => eds.map((e:any)=> e.id===edgeId ? { ...e, data:{ ...(e.data||{}), label: next } } : e));
    await fetch(`/api/edges/${edgeId}`,{
      method:"PATCH", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ label: next })
    }).catch(()=>{});
  },[edges,setEdges]);

  const colorEdge = useCallback(async (edgeId:string, hex:string)=>{
    setEdges(eds => rankParallels(eds.map((e:any)=> e.id===edgeId ? { ...e, data:{ ...(e.data||{}), color: hex } } : e)));
    await fetch(`/api/edges/${edgeId}`,{
      method:"PATCH", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ color: hex })
    }).catch(()=>{});
  },[setEdges]);

  // ----- Menü-Items -----
  const paneItems: MenuItem[] = useMemo(()=>[
    { type:"action", label:"Knoten erstellen", onClick: ()=> addNodeHere(paneCtx.x, paneCtx.y) },
  ],[paneCtx, addNodeHere]);

  const nodeItems = useMemo<MenuItem[]>(()=>[
    { type:"action", label:"Knoten löschen", onClick: ()=> nodeCtx.nodeId && deleteNode(nodeCtx.nodeId) },
    { type:"action", label:"Knoten hinzufügen (mit Relation)", onClick: ()=> nodeCtx.nodeId && addNodeFromNode(nodeCtx.nodeId) },
    { type:"action", label:"Umbenennen", onClick: ()=> nodeCtx.nodeId && renameNode(nodeCtx.nodeId) },
    { type:"color",  label:"Farbe", onChange:(hex)=> nodeCtx.nodeId && colorNode(nodeCtx.nodeId, hex) },
  ],[nodeCtx, deleteNode, addNodeFromNode, renameNode, colorNode]);

  const edgeItems = useMemo<MenuItem[]>(()=>[
    { type:"action", label:"Relation löschen", onClick: ()=> edgeCtx.edgeId && deleteEdge(edgeCtx.edgeId) },
    { type:"action", label:"Text",             onClick: ()=> edgeCtx.edgeId && labelEdge(edgeCtx.edgeId) },
    { type:"color",  label:"Farbe",            onChange:(hex)=> edgeCtx.edgeId && colorEdge(edgeCtx.edgeId, hex) },
  ],[edgeCtx, deleteEdge, labelEdge, colorEdge]);

  return (
    <div className="w-full h-[calc(100vh-64px)]">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onNodeDragStop={onNodeDragStop}
        onNodeContextMenu={onNodeContextMenu}
        onEdgeContextMenu={onEdgeContextMenu}
        onPaneContextMenu={onPaneContextMenu}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        connectionMode={ConnectionMode.Loose}
        defaultEdgeOptions={{ type:"parallel", markerEnd:{ type: MarkerType.ArrowClosed } }}
        fitView
      >
        <Background variant="dots" gap={28} size={1.6} />
        <MiniMap pannable zoomable />
        <Controls />
      </ReactFlow>

      {/* Menüs */}
      <ContextMenu open={paneCtx.open} x={paneCtx.x} y={paneCtx.y} onClose={closePaneMenu} items={paneItems} />
      <ContextMenu open={nodeCtx.open} x={nodeCtx.x} y={nodeCtx.y} onClose={closeNodeMenu} items={nodeItems} />
      <ContextMenu open={edgeCtx.open} x={edgeCtx.x} y={edgeCtx.y} onClose={closeEdgeMenu} items={edgeItems} />
    </div>
  );
}

export default function Editor() {
  return (
    <ReactFlowProvider>
      <Inner />
    </ReactFlowProvider>
  );
}
